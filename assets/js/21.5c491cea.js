(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{345:function(a,t,r){"use strict";r.r(t);var s=r(9),e=Object(s.a)({},function(){var a=this,t=a.$createElement,r=a._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[r("h1",{attrs:{id:"算法"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法","aria-hidden":"true"}},[a._v("#")]),a._v(" 算法")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",{staticClass:"custom-block-title"},[a._v("算法")]),a._v(" "),r("p",[a._v("算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。"),r("br"),a._v("\n设计算法应该尽量满足时间效率高和存储量低的需求。")])]),a._v(" "),r("h2",{attrs:{id:"算法时间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法时间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 算法时间复杂度")]),a._v(" "),r("blockquote",[r("p",[a._v("在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数。"),r("br"),a._v("\n随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称时间复杂度。其中f(n)是问题规模n的某个函数。")])]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[a._v("通过时间复杂度来估算算法时间效率，"),r("br"),a._v("\nT(n) = O(f(n))"),r("br"),a._v("\n用大写O()来体现算法时间复杂度的记法，称之为大O记法。"),r("br"),a._v("\n一般情况下，随着n的增大，T(n)增长最慢的算法为最优算法。")])]),a._v(" "),r("h4",{attrs:{id:"分析算法的时间复杂度："}},[r("a",{staticClass:"header-anchor",attrs:{href:"#分析算法的时间复杂度：","aria-hidden":"true"}},[a._v("#")]),a._v(" 分析算法的时间复杂度：")]),a._v(" "),r("h3",{attrs:{id:"常数阶：o-1-时间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常数阶：o-1-时间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 常数阶：O(1)时间复杂度")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[a._v("问题的大小无关n的多少，执行时间恒定的算法，称之为具有O(1)时间复杂度，又叫常数阶。")])]),a._v(" "),r("h3",{attrs:{id:"线性阶：o-n-时间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线性阶：o-n-时间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 线性阶：O(n)时间复杂度")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[a._v("循环体中的代码须要执行n次。")])]),a._v(" "),r("h3",{attrs:{id:"对数阶：o-logn-时间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对数阶：o-logn-时间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 对数阶：O(logn)时间复杂度")]),a._v(" "),r("h3",{attrs:{id:"平方阶：o-n2-时间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#平方阶：o-n2-时间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 平方阶：O(n"),r("sup",[a._v("2")]),a._v(")时间复杂度")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[a._v("循环体中的代码须要执行n"),r("sup",[a._v("2")]),a._v("次。")])]),a._v(" "),r("h2",{attrs:{id:"算法空间复杂度"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#算法空间复杂度","aria-hidden":"true"}},[a._v("#")]),a._v(" 算法空间复杂度")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[a._v("算法的空间复杂度通过计算算法所需的存储空间实现，"),r("br"),a._v("\nS(n) = O(f(n))"),r("br"),a._v("\nn为问题的规模，f(n)为语句关于n所占存储空间的函数。")])]),a._v(" "),r("p",[a._v("通常都使用“时间复杂度”来指运行时间的需求，使用：“空间复杂度”指空间需求。当不用限定词地使用“复杂度”时，通常都是指时间复杂度。")]),a._v(" "),r("h2",{attrs:{id:"线性表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线性表","aria-hidden":"true"}},[a._v("#")]),a._v(" 线性表")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[a._v("线性表(List)：零个或多个数据元素的有限序列。"),r("br"),a._v("\n线性表元素个数n(n>=0)定义为线性表的长度，当n=0时，称为空表。"),r("br"),a._v("\n对一个线性表来说，插入数据和删除数据都是必须的操作。")])]),a._v(" "),r("h3",{attrs:{id:"线性表的顺序存储结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线性表的顺序存储结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 线性表的顺序存储结构")]),a._v(" "),r("div",{staticClass:"tip custom-block"},[r("p",[a._v("线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。")])]),a._v(" "),r("p",[a._v("描述存储结构需要3个属性：")]),a._v(" "),r("ul",[r("li",[a._v("存储空间的起始位置")]),a._v(" "),r("li",[a._v("线性表的最大存储容量")]),a._v(" "),r("li",[a._v("线性表的当前长度")])]),a._v(" "),r("p",[a._v("在任意时刻，线性表的长度应该<=数组的长度。")]),a._v(" "),r("p",[a._v("用数组存储顺序意味着要分配固定长度的数组空间，由于线性表中可以进行插入和删除操作，因此分配的数组空间要>=当前线性表的长度。")]),a._v(" "),r("p",[a._v("其实，内存中的地址，就和图书馆或电影院里的座位一样，都是有编号的。存储器中的每个存储单元都有自己的编号，这个编号称为地址。")]),a._v(" "),r("p",[a._v("线性表的顺序存储结构，在存、读数据时，不管是哪个位置，时间复杂度都是O(1)；而插入或删除时，时间复杂度都是O(n)。这就说明它比较适合元素个数不太变化，更多是存取数据的应用。")]),a._v(" "),r("h3",{attrs:{id:"线性表的链式存储结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#线性表的链式存储结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 线性表的链式存储结构")]),a._v(" "),r("h4",{attrs:{id:"单链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#单链表","aria-hidden":"true"}},[a._v("#")]),a._v(" 单链表")]),a._v(" "),r("p",[a._v("线性表的顺序存储结构最大的缺点是插入和删除时需要移动大量元素。")]),a._v(" "),r("p",[a._v("我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素的存储映像，称为结点(Node)。")]),a._v(" "),r("p",[a._v("由于单链表的结构中没有定义表长，所以不能事先知道要循环多少次，其主要核心思想是“工作指针后移”。")]),a._v(" "),r("p",[a._v("如果我们希望从第i个位置，插入10个结点，对于顺序存储结构意味着，每一次插入都要移动n-1个结点，每次都是O(n)。而单链表，我们只需要在第一次时，找到第i个位置的指针，此时为O(n)，接下来只是简单地通过赋值移动指针而已，时间复杂度都是O(1)。")]),a._v(" "),r("p",[a._v("对于插入或删除数据越频繁的操作，单链表的效率优势就越明显。")]),a._v(" "),r("h3",{attrs:{id:"静态链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#静态链表","aria-hidden":"true"}},[a._v("#")]),a._v(" 静态链表")]),a._v(" "),r("blockquote",[r("p",[a._v("用数组描述的链表叫做静态链表。或叫游标实现法。")])]),a._v(" "),r("p",[a._v("让数组的元素都是由两个域组成，data和cur。也就是说，数组的每个下标都对应一个data和cur。数据域data用来存放数据元素，也就是通常我们要处理的数据；cur相当于单链表中的next指针，存放该元素的后继在数组中的下标，把cur叫做游标。")]),a._v(" "),r("p",[a._v("在插入和删除时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点。但是没有解决连续存储分配带来的表长难以确定的问题。")]),a._v(" "),r("h3",{attrs:{id:"循环链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环链表","aria-hidden":"true"}},[a._v("#")]),a._v(" 循环链表")]),a._v(" "),r("blockquote",[r("p",[a._v("将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表。")])]),a._v(" "),r("p",[a._v("循环链表和单链表的主要差异在于循环的判断条件上，原来是判断p->next是否为空，现在则是p->next不等于头结点，则循环未结束。")]),a._v(" "),r("h3",{attrs:{id:"双向链表"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#双向链表","aria-hidden":"true"}},[a._v("#")]),a._v(" 双向链表")]),a._v(" "),r("p",[a._v("在单链表中，有了next指针，这就使得我们要查找下一结点的时间复杂度为O(1)，可是如果我们要查找的是上一结点的话，那最坏的时间复杂度就是O(n)了，因为我们每次都要从头开始遍历查找。")]),a._v(" "),r("p",[a._v("为了克服单向性这一缺点，设计出了双向链表，双向链表是在单链表的每个结点中，再设置一个指向前驱结点的指针域。所以在双向链表中的结点都有两个指针域，一个指向直接后继，另一个指向直接前驱。")]),a._v(" "),r("h2",{attrs:{id:"栈与队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈与队列","aria-hidden":"true"}},[a._v("#")]),a._v(" 栈与队列")]),a._v(" "),r("h3",{attrs:{id:"栈的定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈的定义","aria-hidden":"true"}},[a._v("#")]),a._v(" 栈的定义")]),a._v(" "),r("h3",{attrs:{id:"栈的顺序存储结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈的顺序存储结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 栈的顺序存储结构")]),a._v(" "),r("h3",{attrs:{id:"栈的链式存储结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈的链式存储结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 栈的链式存储结构")]),a._v(" "),r("h3",{attrs:{id:"栈的作用"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈的作用","aria-hidden":"true"}},[a._v("#")]),a._v(" 栈的作用")]),a._v(" "),r("h3",{attrs:{id:"栈的应用——递归"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈的应用——递归","aria-hidden":"true"}},[a._v("#")]),a._v(" 栈的应用——递归")]),a._v(" "),r("h3",{attrs:{id:"栈的应用——四则运算表达式求值"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#栈的应用——四则运算表达式求值","aria-hidden":"true"}},[a._v("#")]),a._v(" 栈的应用——四则运算表达式求值")]),a._v(" "),r("h3",{attrs:{id:"队列的定义"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队列的定义","aria-hidden":"true"}},[a._v("#")]),a._v(" 队列的定义")]),a._v(" "),r("h3",{attrs:{id:"循环队列"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#循环队列","aria-hidden":"true"}},[a._v("#")]),a._v(" 循环队列")]),a._v(" "),r("h3",{attrs:{id:"队列的链式存储结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#队列的链式存储结构","aria-hidden":"true"}},[a._v("#")]),a._v(" 队列的链式存储结构")]),a._v(" "),r("h2",{attrs:{id:"串"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#串","aria-hidden":"true"}},[a._v("#")]),a._v(" 串")]),a._v(" "),r("h2",{attrs:{id:"树"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#树","aria-hidden":"true"}},[a._v("#")]),a._v(" 树")]),a._v(" "),r("h2",{attrs:{id:"图"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#图","aria-hidden":"true"}},[a._v("#")]),a._v(" 图")]),a._v(" "),r("h2",{attrs:{id:"查找"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#查找","aria-hidden":"true"}},[a._v("#")]),a._v(" 查找")]),a._v(" "),r("h2",{attrs:{id:"排序"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#排序","aria-hidden":"true"}},[a._v("#")]),a._v(" 排序")])])},[],!1,null,null,null);t.default=e.exports}}]);